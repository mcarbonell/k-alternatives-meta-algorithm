<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización de árbol k-d</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        canvas {
            border: 1px solid #000;
            margin-top: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        input,
        button {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <h1>Arbol K D</h1>

    <div class="controls">
        <label for="numPoints">Número inicial de puntos:</label>
        <input type="number" id="numPoints" value="20" min="1" max="1000">
        <label for="numNearest">Número de puntos cercanos:</label>
        <input type="number" id="numNearest" value="5" min="1" max="20">
        <button id="generate">Generar puntos</button>
    </div>
    <div class="controls">
        <label for="numAddPoints">Número de puntos a añadir:</label>
        <input type="number" id="numAddPoints" value="10" min="1" max="100">
        <button id="addPoints">Añadir puntos</button>
    </div>
    <canvas id="canvas" width="600" height="600"></canvas>

    <textarea name="cities" id="citiesinput" cols="50" rows="20"></textarea>

    <script>
        class Node {
            constructor(point, axis) {
                this.point = point;
                this.left = null;
                this.right = null;
                this.axis = axis;
            }
        }

        class KDTree {
            constructor(points) {
                this.root = this.buildTree(points, 0);
            }

            buildTree(points, depth) {
                if (points.length === 0) return null;

                const axis = depth % 2;
                points.sort((a, b) => a[axis] - b[axis]);

                const medianIndex = Math.floor(points.length / 2);
                const node = new Node(points[medianIndex], axis);

                node.left = this.buildTree(points.slice(0, medianIndex), depth + 1);
                node.right = this.buildTree(points.slice(medianIndex + 1), depth + 1);

                return node;
            }

            insert(point) {
                this.root = this._insert(this.root, point, 0);
            }

            _insert(node, point, depth) {
                if (node === null) {
                    return new Node(point, depth % 2);
                }

                const axis = depth % 2;

                if (point[axis] < node.point[axis]) {
                    node.left = this._insert(node.left, point, depth + 1);
                } else {
                    node.right = this._insert(node.right, point, depth + 1);
                }

                return node;
            }

            nearestNeighbors(point, k) {
                const neighbors = [];
                this.searchNearest(this.root, point, k, neighbors);
                return neighbors;
            }

            searchNearest(node, point, k, neighbors) {
                if (!node) return;

                const distance = this.distance(point, node.point);

                if (neighbors.length < k) {
                    neighbors.push({ point: node.point, distance });
                    neighbors.sort((a, b) => a.distance - b.distance);
                } else if (distance < neighbors[neighbors.length - 1].distance) {
                    neighbors.pop();
                    neighbors.push({ point: node.point, distance });
                    neighbors.sort((a, b) => a.distance - b.distance);
                }

                const axis = node.axis;
                const diff = point[axis] - node.point[axis];

                this.searchNearest(diff < 0 ? node.left : node.right, point, k, neighbors);

                if (neighbors.length < k || Math.abs(diff) < neighbors[neighbors.length - 1].distance) {
                    this.searchNearest(diff < 0 ? node.right : node.left, point, k, neighbors);
                }
            }

            distance(a, b) {
                return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const generateButton = document.getElementById('generate');
        const addPointsButton = document.getElementById('addPoints');
        const numPointsInput = document.getElementById('numPoints');
        const numNearestInput = document.getElementById('numNearest');
        const numAddPointsInput = document.getElementById('numAddPoints');

        const citiesInput = document.querySelector('#citiesinput');

        let points = [];
        let kdTree;
        let nearestPoints = [];
        let clickPoint = null;

        function generatePoints() {
            const numPoints = parseInt(numPointsInput.value);
            points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push([Math.random() * canvas.width, Math.random() * canvas.height]);
            }
            kdTree = new KDTree(points);
            nearestPoints = [];
            clickPoint = null;
            drawPoints();
            citiesInput.value = JSON.stringify(points, null, 2);
        }

        function addPoints() {
            const numAddPoints = parseInt(numAddPointsInput.value);
            for (let i = 0; i < numAddPoints; i++) {
                const newPoint = [Math.random() * canvas.width, Math.random() * canvas.height];
                points.push(newPoint);
                kdTree.insert(newPoint);
            }
            drawPoints();
            citiesInput.value = JSON.stringify(points, null, 2);
        }

        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar todos los puntos en rojo
            ctx.fillStyle = 'red';
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Dibujar los puntos más cercanos en verde
            ctx.fillStyle = 'green';
            nearestPoints.forEach(nearest => {
                ctx.beginPath();
                ctx.arc(nearest.point[0], nearest.point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Dibujar el punto de clic en negro
            if (clickPoint) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(clickPoint[0], clickPoint[1], 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            clickPoint = [x, y];

            const k = parseInt(numNearestInput.value);
            nearestPoints = kdTree.nearestNeighbors(clickPoint, k);
            drawPoints();
        });

        generateButton.addEventListener('click', generatePoints);
        addPointsButton.addEventListener('click', addPoints);

        citiesInput.addEventListener('input', () => {
            try {

                // Intentar parsear el contenido del textarea como JSON
                let jsonText = citiesInput.value.replace(/^\s+|\s+$/g, ''); //Elimina espacios al inicio o al final
                let parsedJSON = JSON.parse(jsonText);

                // Si llegamos aquí, el JSON es válido
                // Actualizar el array con el nuevo contenido
                points = [];
                for (const point of parsedJSON) {
                    points.push([point.x, point.y]);
                }
                // console.log('parse input', points);
                // generateRandomPoints();
                kdTree = new KDTree(points);
                nearestPoints = [];
                clickPoint = null;
                drawPoints();

            } catch (error) {
                // Si llegamos aquí, el JSON no es válido
                console.error('JSON inválido:', error);
            }
        });

        generatePoints();
    </script>
</body>

</html>