<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización de árbol k-d</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        input, button {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="numPoints">Número de puntos:</label>
        <input type="number" id="numPoints" value="100" min="1" max="1000">
        <label for="numNearest">Número de puntos cercanos:</label>
        <input type="number" id="numNearest" value="5" min="1" max="20">
        <button id="generate">Generar puntos</button>
    </div>
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        class Node {
            constructor(point, axis) {
                this.point = point;
                this.left = null;
                this.right = null;
                this.axis = axis;
            }
        }

        class KDTree {
            constructor(points) {
                this.root = this.buildTree(points, 0);
            }

            buildTree(points, depth) {
                if (points.length === 0) return null;

                const axis = depth % 2;
                points.sort((a, b) => a[axis] - b[axis]);

                const medianIndex = Math.floor(points.length / 2);
                const node = new Node(points[medianIndex], axis);

                node.left = this.buildTree(points.slice(0, medianIndex), depth + 1);
                node.right = this.buildTree(points.slice(medianIndex + 1), depth + 1);

                return node;
            }

            nearestNeighbors(point, k) {
                const neighbors = [];
                this.searchNearest(this.root, point, k, neighbors);
                return neighbors;
            }

            searchNearest(node, point, k, neighbors) {
                if (!node) return;

                const distance = this.distance(point, node.point);

                if (neighbors.length < k) {
                    neighbors.push({ point: node.point, distance });
                    neighbors.sort((a, b) => a.distance - b.distance);
                } else if (distance < neighbors[neighbors.length - 1].distance) {
                    neighbors.pop();
                    neighbors.push({ point: node.point, distance });
                    neighbors.sort((a, b) => a.distance - b.distance);
                }

                const axis = node.axis;
                const diff = point[axis] - node.point[axis];

                this.searchNearest(diff < 0 ? node.left : node.right, point, k, neighbors);

                if (neighbors.length < k || Math.abs(diff) < neighbors[neighbors.length - 1].distance) {
                    this.searchNearest(diff < 0 ? node.right : node.left, point, k, neighbors);
                }
            }

            distance(a, b) {
                return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const generateButton = document.getElementById('generate');
        const numPointsInput = document.getElementById('numPoints');
        const numNearestInput = document.getElementById('numNearest');

        let points = [];
        let kdTree;
        let nearestPoints = [];
        let clickPoint = null;

        function generatePoints() {
            const numPoints = parseInt(numPointsInput.value);
            points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push([Math.random() * canvas.width, Math.random() * canvas.height]);
            }
            kdTree = new KDTree(points);
            nearestPoints = [];
            clickPoint = null;
            drawPoints();
        }

        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar todos los puntos en rojo
            ctx.fillStyle = 'red';
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Dibujar los puntos más cercanos en verde
            ctx.fillStyle = 'green';
            nearestPoints.forEach(nearest => {
                ctx.beginPath();
                ctx.arc(nearest.point[0], nearest.point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Dibujar el punto de clic en negro
            if (clickPoint) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(clickPoint[0], clickPoint[1], 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            clickPoint = [x, y];

            const k = parseInt(numNearestInput.value);
            nearestPoints = kdTree.nearestNeighbors(clickPoint, k);
            drawPoints();
        });

        generateButton.addEventListener('click', generatePoints);

        generatePoints();
    </script>
</body>
</html>
