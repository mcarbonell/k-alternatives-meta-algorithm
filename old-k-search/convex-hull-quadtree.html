<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convex Hull con Quadtree</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 1px solid black;
            margin-top: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="numPoints">Número de puntos:</label>
        <input type="number" id="numPoints" min="3" value="20">
        <button id="generatePoints">Generar Puntos</button>
        <button id="calculateHull">Calcular Convex Hull</button>
    </div>
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const numPointsInput = document.getElementById('numPoints');
        const generateButton = document.getElementById('generatePoints');
        const calculateButton = document.getElementById('calculateHull');

        let points = [];

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.points = [];
                this.divided = false;
            }

            insert(point) {
                if (!this.boundary.contains(point)) {
                    return false;
                }

                if (this.points.length < this.capacity) {
                    this.points.push(point);
                    return true;
                }

                if (!this.divided) {
                    this.subdivide();
                }

                return (this.northeast.insert(point) || this.northwest.insert(point) ||
                        this.southeast.insert(point) || this.southwest.insert(point));
            }

            subdivide() {
                const x = this.boundary.x;
                const y = this.boundary.y;
                const w = this.boundary.w / 2;
                const h = this.boundary.h / 2;

                const ne = new Rectangle(x + w, y - h, w, h);
                this.northeast = new QuadTree(ne, this.capacity);
                const nw = new Rectangle(x - w, y - h, w, h);
                this.northwest = new QuadTree(nw, this.capacity);
                const se = new Rectangle(x + w, y + h, w, h);
                this.southeast = new QuadTree(se, this.capacity);
                const sw = new Rectangle(x - w, y + h, w, h);
                this.southwest = new QuadTree(sw, this.capacity);

                this.divided = true;
            }

            query(range, found) {
                if (!found) {
                    found = [];
                }

                if (!this.boundary.intersects(range)) {
                    return found;
                }

                for (let p of this.points) {
                    if (range.contains(p)) {
                        found.push(p);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }

                return found;
            }
        }

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            contains(point) {
                return (point.x >= this.x - this.w &&
                        point.x < this.x + this.w &&
                        point.y >= this.y - this.h &&
                        point.y < this.y + this.h);
            }

            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        function generateRandomPoints(n) {
            points = [];
            for (let i = 0; i < n; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                points.push(new Point(x, y));
            }
            drawPoints();
        }

        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'blue';
            for (let point of points) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function calculateConvexHull() {
            if (points.length < 3) return points;

            const boundary = new Rectangle(canvas.width/2, canvas.height/2, canvas.width/2, canvas.height/2);
            const quadtree = new QuadTree(boundary, 4);
            for (let point of points) {
                quadtree.insert(point);
            }

            // Encontrar puntos extremos
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            let leftmost, rightmost, topmost, bottommost;

            for (let point of points) {
                if (point.x < minX) {
                    minX = point.x;
                    leftmost = point;
                }
                if (point.x > maxX) {
                    maxX = point.x;
                    rightmost = point;
                }
                if (point.y < minY) {
                    minY = point.y;
                    topmost = point;
                }
                if (point.y > maxY) {
                    maxY = point.y;
                    bottommost = point;
                }
            }

            let hull = [leftmost, topmost, rightmost, bottommost];
            hull = hull.filter((v, i, a) => a.indexOf(v) === i); // Eliminar duplicados

            // Función para determinar si un punto está a la izquierda de la línea formada por dos puntos
            function isLeft(a, b, c) {
                return ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x)) > 0;
            }

            // Función recursiva para encontrar puntos del casco convexo
            function findHullPoints(quadtree, a, b, hull) {
                const searchArea = new Rectangle((a.x + b.x) / 2, (a.y + b.y) / 2, 
                                                 Math.abs(a.x - b.x) / 2, Math.abs(a.y - b.y) / 2);
                const potentialPoints = quadtree.query(searchArea);

                let maxDistance = 0;
                let farthestPoint = null;

                for (let point of potentialPoints) {
                    if (isLeft(a, b, point)) {
                        const distance = Math.abs((b.x - a.x) * (a.y - point.y) - (a.x - point.x) * (b.y - a.y));
                        if (distance > maxDistance) {
                            maxDistance = distance;
                            farthestPoint = point;
                        }
                    }
                }

                if (farthestPoint !== null) {
                    findHullPoints(quadtree, a, farthestPoint, hull);
                    hull.push(farthestPoint);
                    findHullPoints(quadtree, farthestPoint, b, hull);
                }
            }

            // Encontrar el resto de los puntos del casco convexo
            for (let i = 0; i < hull.length; i++) {
                const a = hull[i];
                const b = hull[(i + 1) % hull.length];
                findHullPoints(quadtree, a, b, hull);
            }

            // Ordenar los puntos del casco convexo
            const center = hull.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x: 0, y: 0});
            center.x /= hull.length;
            center.y /= hull.length;

            hull.sort((a, b) => Math.atan2(a.y - center.y, a.x - center.x) - 
                                Math.atan2(b.y - center.y, b.x - center.x));

            return hull;
        }

        function drawConvexHull(hull) {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(hull[0].x, hull[0].y);
            for (let i = 1; i < hull.length; i++) {
                ctx.lineTo(hull[i].x, hull[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        generateButton.addEventListener('click', () => {
            const numPoints = parseInt(numPointsInput.value);
            generateRandomPoints(numPoints);
        });

        calculateButton.addEventListener('click', () => {
            const hull = calculateConvexHull();
            drawPoints();
            drawConvexHull(hull);
        });

        // Generar puntos iniciales
        generateRandomPoints(parseInt(numPointsInput.value));
    </script>
</body>
</html>
