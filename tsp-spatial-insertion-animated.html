<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP - Depuraci贸n KD-Tree e Inserci贸n</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; display: flex; flex-direction: column; align-items: center; }
        canvas { border: 1px solid black; cursor: crosshair; margin-top: 10px; }
        .controls { margin: 10px; padding: 15px; background: #f0f0f0; border-radius: 8px; text-align: left; }
        button { padding: 8px 16px; font-size: 14px; cursor: pointer; margin-right: 5px; }
        .stats { margin-top: 10px; font-family: monospace; font-size: 16px; background: #333; color: #fff; padding: 5px 10px; border-radius: 4px;}
        .legend { font-size: 12px; color: #666; margin-top: 5px; }
        label { margin-right: 10px; display: inline-block; margin-bottom: 5px;}
        .mode-group { margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
    </style>
</head>
<body>
    <h1>TSP - Depuraci贸n Espacial</h1>
    
    <div class="controls">
        <div class="mode-group">
            <strong>Modo:</strong>
            <label><input type="radio" name="mode" value="insert" checked> Insertar & Optimizar</label>
            <label><input type="radio" name="mode" value="inspect"> Inspeccionar Vecinos (KD-Tree)</label>
        </div>

        <button onclick="generateRandom(30)">Generar 30 Aleatorios</button>
        <button onclick="clearCanvas()">Limpiar</button>
        <br>
        <label>Vecinos (M): <input type="number" id="kNeighbors" value="10" min="3" max="100"></label>
        <label>Velocidad (ms): <input type="number" id="delay" value="100" min="0" max="1000"></label>
        <label>Auto-Play: <input type="checkbox" id="autoplay" checked></label>
    </div>

    <canvas id="tspCanvas" width="800" height="500"></canvas>
    <div class="stats" id="stats">Nodos: 0 | Costo: 0.00 | Estado: Listo</div>
    <div class="legend">
         Nodo Est谩tico |  ltimo Insertado |  En Cola (ActiveSet) |  L铆neas de Inspecci贸n
    </div>

    <script>
        // --- KD-Tree Implementation ---
        class Node {
            constructor(point, axis, data) {
                this.point = point;
                this.left = null;
                this.right = null;
                this.axis = axis;
                this.data = data;
            }
        }

        class KDTree {
            constructor(points) {
                const formatted = points.map(p => ({ arr: [p.x, p.y], data: p }));
                this.root = this.buildTree(formatted, 0);
            }

            buildTree(points, depth) {
                if (points.length === 0) return null;
                const axis = depth % 2;
                points.sort((a, b) => a.arr[axis] - b.arr[axis]);
                const medianIndex = Math.floor(points.length / 2);
                const node = new Node(points[medianIndex].arr, axis, points[medianIndex].data);
                node.left = this.buildTree(points.slice(0, medianIndex), depth + 1);
                node.right = this.buildTree(points.slice(medianIndex + 1), depth + 1);
                return node;
            }

            insert(city) {
                const point = [city.x, city.y];
                if (!this.root) this.root = new Node(point, 0, city);
                else this._insertRecursive(this.root, point, city, 0);
            }

            _insertRecursive(node, point, data, depth) {
                const axis = depth % 2;
                if (point[axis] < node.point[axis]) {
                    if (node.left === null) node.left = new Node(point, (depth + 1) % 2, data);
                    else this._insertRecursive(node.left, point, data, depth + 1);
                } else {
                    if (node.right === null) node.right = new Node(point, (depth + 1) % 2, data);
                    else this._insertRecursive(node.right, point, data, depth + 1);
                }
            }

            nearestNeighbors(x, y, k) {
                const point = [x, y];
                const neighbors = [];
                this.searchNearest(this.root, point, k, neighbors);
                return neighbors.map(n => n.node.data);
            }

            searchNearest(node, point, k, neighbors) {
                if (!node) return;
                const d = Math.hypot(point[0] - node.point[0], point[1] - node.point[1]);
                
                // Add to list if space or closer than worst
                let added = false;
                if (neighbors.length < k) {
                    neighbors.push({ node, distance: d });
                    added = true;
                } else if (d < neighbors[neighbors.length - 1].distance) {
                    neighbors.pop();
                    neighbors.push({ node, distance: d });
                    added = true;
                }

                if (added) {
                    neighbors.sort((a, b) => a.distance - b.distance);
                }

                const axis = node.axis;
                const diff = point[axis] - node.point[axis];
                const nearChild = diff < 0 ? node.left : node.right;
                const farChild = diff < 0 ? node.right : node.left;

                this.searchNearest(nearChild, point, k, neighbors);

                if (neighbors.length < k || Math.abs(diff) < neighbors[neighbors.length - 1].distance) {
                    this.searchNearest(farChild, point, k, neighbors);
                }
            }
        }

        // --- Main Logic ---
        const canvas = document.getElementById('tspCanvas');
        const ctx = canvas.getContext('2d');
        const statsDiv = document.getElementById('stats');
        
        let cities = [];
        let tour = []; 
        let kdtree = new KDTree([]);
        let isOptimizing = false;
        
        // Visual State
        let activeSet = new Set(); 
        let lastInsertedId = -1;
        let inspectNeighbors = [];
        let inspectPoint = null;

        function clearCanvas() {
            cities = [];
            tour = [];
            kdtree = new KDTree([]);
            activeSet.clear();
            inspectNeighbors = [];
            inspectPoint = null;
            drawState();
        }

        async function generateRandom(n) {
            if(isOptimizing) return;
            clearCanvas();
            const autoplay = document.getElementById('autoplay').checked;
            for(let i=0; i<n; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                // Only animate the last few to save time if n is large
                await addCityInternal(x, y, autoplay && i > n - 5); 
            }
            drawState();
        }

        canvas.addEventListener('click', async (event) => {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            if (mode === 'insert') {
                if(isOptimizing) return;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                await addCityInternal(x, y, true);
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            if (mode === 'inspect') {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                const k = parseInt(document.getElementById('kNeighbors').value);
                
                inspectPoint = {x, y};
                inspectNeighbors = kdtree.nearestNeighbors(x, y, k);
                drawState();
            }
        });

        async function addCityInternal(x, y, animate) {
            const newCity = {x, y, id: cities.length};
            cities.push(newCity);
            kdtree.insert(newCity);
            lastInsertedId = newCity.id;

            if (cities.length <= 3) {
                tour.push(newCity.id);
                drawState();
            } else {
                await insertCityAndOptimize(newCity.id, animate);
            }
        }

        async function insertCityAndOptimize(cityIndex, animate) {
            isOptimizing = true;
            let bestInsertion = { cost: Infinity, idx: -1 };
            
            // 1. Initial Greedy Insertion (Global)
            for (let i = 0; i < tour.length; i++) {
                const j = (i + 1) % tour.length;
                const cost = insertionCost(cityIndex, tour[i], tour[j]);
                if (cost < bestInsertion.cost) {
                    bestInsertion = { cost, idx: i };
                }
            }
            tour.splice(bestInsertion.idx + 1, 0, cityIndex);
            
            if (animate) {
                updateStats("Insertando...");
                drawState();
                await sleep(50); 
            }

            // 2. Cascade Optimization
            // Start optimizing the new city AND its immediate neighbors (because their edges changed)
            const prevIdx = bestInsertion.idx;
            const nextIdx = (bestInsertion.idx + 2) % tour.length; // +2 because tour grew by 1
            const startNodes = [cityIndex, tour[prevIdx], tour[nextIdx]];
            
            await optimizeNeighbors(startNodes, animate);
            
            isOptimizing = false;
            lastInsertedId = -1;
            activeSet.clear();
            updateStats("Listo");
            drawState();
        }

        async function optimizeNeighbors(startNodeIds, animate) {
            let modified = new Set(startNodeIds);
            activeSet = modified; 
            
            const maxK = parseInt(document.getElementById('kNeighbors').value);
            const delay = parseInt(document.getElementById('delay').value);

            let iterations = 0;
            const MAX_ITER = cities.length * 10; // Increased safety limit

            while (modified.size > 0 && iterations < MAX_ITER) {
                iterations++;
                // Peek only, don't delete yet so it draws as yellow
                const currentCityId = modified.values().next().value;
                
                const currentPos = tour.indexOf(currentCityId);
                if (currentPos === -1) {
                    modified.delete(currentCityId);
                    continue;
                }

                // Highlight currently processing node
                if (animate) {
                     updateStats(`Evaluando nodo ${currentCityId}...`);
                     drawState();
                     await sleep(Math.max(20, delay / 2));
                }

                // Now we can remove it from the working set for logic, 
                // but ideally we keep it in 'activeSet' for viz... 
                // Ideally 'activeSet' should be separate from 'modified', but for simplicity:
                // We will delete it at the END of the loop iteration.

                // --- Logic ---
                const neighbors = kdtree.nearestNeighbors(cities[currentCityId].x, cities[currentCityId].y, maxK);
                
                const prevPos = (currentPos - 1 + tour.length) % tour.length;
                const nextPos = (currentPos + 1) % tour.length;
                const prevCityId = tour[prevPos];
                const nextCityId = tour[nextPos];

                const currentCostContribution = 
                    dist(cities[prevCityId], cities[currentCityId]) + 
                    dist(cities[currentCityId], cities[nextCityId]);
                
                const bridgedCost = dist(cities[prevCityId], cities[nextCityId]);
                const savingByRemoval = currentCostContribution - bridgedCost;

                let bestMove = { gain: 0, pos: -1 };

                const candidatePositions = new Set();
                neighbors.forEach(neighbor => {
                    const neighborPos = tour.indexOf(neighbor.id);
                    if (neighborPos !== -1) {
                        candidatePositions.add(neighborPos); 
                        candidatePositions.add((neighborPos + 1) % tour.length); 
                    }
                });

                candidatePositions.forEach(pos => {
                    if (pos === currentPos || pos === (currentPos + 1) % tour.length) return;
                    
                    const p = (pos - 1 + tour.length) % tour.length;
                    const nodeP = tour[p];
                    const nodeN = tour[pos]; // index pos is the node AFTER insertion point

                    // Fix logic: insert AT index 'pos' means between tour[pos-1] and tour[pos]
                    // So nodes are tour[p] and tour[pos]
                    // Avoid inserting next to self (already filtered by pos checks but be safe)
                    if (nodeP === currentCityId || nodeN === currentCityId) return;

                    const costToInsert = 
                        dist(cities[nodeP], cities[currentCityId]) + 
                        dist(cities[currentCityId], cities[nodeN]) - 
                        dist(cities[nodeP], cities[nodeN]);

                    const gain = savingByRemoval - costToInsert;

                    // Using a small epsilon preference for stability
                    if (gain > 0.000001 && gain > bestMove.gain) {
                        bestMove = { gain, pos: pos, nodeP, nodeN };
                    }
                });

                if (bestMove.gain > 0) {
                    // Apply Move
                    tour.splice(currentPos, 1);
                    let newIdxP = tour.indexOf(bestMove.nodeP);
                    tour.splice(newIdxP + 1, 0, currentCityId);

                    // Propagate:
                    // 1. Neighbors of OLD position (now connected to each other)
                    modified.add(prevCityId);
                    modified.add(nextCityId);
                    // 2. Neighbors of NEW position (now separated)
                    modified.add(bestMove.nodeP);
                    modified.add(bestMove.nodeN);
                    
                    // 3. The node itself moved, maybe it wants to move again?
                    // modified.add(currentCityId); 

                    if (animate) {
                        updateStats(`Moviendo nodo ${currentCityId} (Gain: ${bestMove.gain.toFixed(1)})`);
                        drawState();
                        await sleep(delay);
                    }
                }
                
                // Remove processed node from set
                modified.delete(currentCityId);
            }
        }

        function insertionCost(cityIdx, prevIdx, nextIdx) {
            return dist(cities[cityIdx], cities[prevIdx]) + 
                   dist(cities[cityIdx], cities[nextIdx]) - 
                   dist(cities[prevIdx], cities[nextIdx]);
        }

        function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        function tourCost() {
            let c = 0;
            for (let i = 0; i < tour.length; i++) {
                c += dist(cities[tour[i]], cities[tour[(i + 1) % tour.length]]);
            }
            return c;
        }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        
        function updateStats(state) {
            statsDiv.textContent = `Nodos: ${cities.length} | Costo: ${tourCost().toFixed(2)} | Estado: ${state}`;
        }

        function drawState() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Tour
            if (tour.length > 0) {
                ctx.beginPath();
                const start = cities[tour[0]];
                ctx.moveTo(start.x, start.y);
                for (let i = 1; i <= tour.length; i++) {
                    const city = cities[tour[i % tour.length]];
                    ctx.lineTo(city.x, city.y);
                }
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Inspect Mode: Lines to neighbors
            if (document.querySelector('input[name="mode"]:checked').value === 'inspect' && inspectPoint) {
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
                ctx.lineWidth = 1;
                inspectNeighbors.forEach(n => {
                    ctx.beginPath();
                    ctx.moveTo(inspectPoint.x, inspectPoint.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                });
                // Draw cursor point
                ctx.beginPath();
                ctx.arc(inspectPoint.x, inspectPoint.y, 3, 0, 2*Math.PI);
                ctx.fillStyle = 'blue';
                ctx.fill();
            }

            // Draw Cities
            for (let i = 0; i < cities.length; i++) {
                const city = cities[i];
                ctx.beginPath();
                ctx.arc(city.x, city.y, 5, 0, 2 * Math.PI);
                
                if (city.id === lastInsertedId) ctx.fillStyle = '#28a745'; // Green
                else if (activeSet.has(city.id)) ctx.fillStyle = '#ffc107'; // Yellow
                else ctx.fillStyle = '#dc3545'; // Red
                
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Debug text
                // ctx.fillStyle = 'black';
                // ctx.fillText(city.id, city.x + 8, city.y);
            }
        }
    </script>
</body>
</html>